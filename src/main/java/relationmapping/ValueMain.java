package relationmapping;

/**
 * 값 타입
 *   기본 값 타입
 *   - 자바 기본 타입(int, double)
 *   - 래퍼 클래스(Integer, Long)
 *   - String
 *   자바의 기본 타입은 절대 공유하면 안됨.
 *   기본 타입은 항상 값을 복사함.
 *   Integer 같은 래퍼 클래스나 String 같은 특수한 클래스는 공유 가능한 객체이지만 변경되지 않음.
 *
 *   임베디드 타입(복합 값 타입)
 *   - 새로운 값 타입을 직접 정의할 수 있음
 *   - JPA는 임베디드 타입이라 함
 *   - 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함
 *   - int, String과 같은 값 타입(엔티티가 아님)
 *
 *   장점
 *   - 재사용성
 *   - 높은 응집도
 *   - 해당 값 타입만 사용하는 의미있는 메서드를 만들 수 있음
 *   - 임베디드 타입을 포함한 모든 값 타입은 값 타입을 소유한 엔티티에 생명주기를 의존함
 *
 *   임베디드 타입과 테이블 매핑
 *   - 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다!!
 *   - 객체와 테이블을 아주 세밀하게 매핑하는 것이 가능하다.
 *   - 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많다.
 *
 *   만약 한 엔티티에서 같은 값 타입을 사용하면?
 *   - 컬럼 명이 중복되므로 @AttributeOverrides/@AttributeOverride로 속성을 재정의 해주어야 한다!
 *
 *   객체 타입의 한계
 *   - 임베디드 타입 같은 객체 타입은 공유 참조를 (컴파일 타임에) 막을 수도 없고 피할 수도 없다.
 *
 *   객체 타입의 한계 극복
 *   - 불변 객체로 설계한다!
 *   - 가장 쉬운 방법 : 생성자로만 값을 설정하고 setter를 안만들면 됨.(또는 private setter만 만듬)
 *   - 참고 : Integer나 String이 자바의 대표적인 불변 객체이다.
 *
 *   그렇다면 객체 타입의 값을 바꾸고 싶은 상황에는 어떻게 하나?
 *   - 새로 객체를 만들어서 생성자에 바꾸고 싶은 값으로 넣어서 대입해야한다.
 *
 *   정리 : 깔끔하게 모든 값 타입은 불변 객체로 만들어야한다!!!!
 *
 *   값 타입의 비교
 *   - 동일성(identity) 비교 : 인스턴스의 참조 값을 비교, == 사용
 *   - 동등성(equivalence) 비교 : 인스턴스의 값을 비교, equals() 사용
 *   - 값 타입(임베디드/객체 타입)의 비교는 항상 equals()를 사용해서 비교해야한다.
 *
 *   값 타입 컬렉션
 *   - 그렇다면 값 타입을 컬렉션으로 사용할 때 관계형 DB에는 어떻게 저장해야 할까?(ex: Set<String>)
 *     -> 별도의 테이블로 뽑아야한다!
 *   - 값 타입 컬렉션을 별도의 테이블로 뽑을 때는 모든 컬럼으로 하나의 PK로 만들어야한다.
 *     -> 만약 ID 같은 하나의 컬럼으로 PK를 만들면 그것은 엔티티이다.
 *   - @ElementCollection, @CollectionTable 사용!
 *   - 값 타입 컬렉션도 스스로의 생명주기가 없고 소유 엔티티와 생명주기가 같다.
 *     그러므로 소유 엔티티의 값 타입 컬렉션이 변경되면 값 타입 컬렉션은 자동으로 persist 된다!
 *     즉, 값 타입 컬렉션은 영속성 전이 및 고아 객체 제거 기능을 필수로 가진다.
 *     또한 값 타입 컬렉션은 지연 로딩 전략으로 설정된다.
 *
 *   값 타입 컬렉션의 제약 사항
 *   - 값 타입 컬렉션에 변경 사항이 발생하면 주인 엔티티와 연관된 모든 데이터를 삭제하고,
 *     값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다.
 *     즉, 절대 사용해서는 안된다!
 *
 *   값 타입 컬렉션에서 발생하는 제약 사항 때문에 대안이 필요하다.
 *   - 값 타입 컬렉션 대신에 일대다 관계를 고려해라!(ex: Address -> AddressEntity)
 *   - 영속성 전이와 고아 객체 제거를 사용해서 값 타입 컬렉션처럼 엔티티를 만들어 사용함.
 *
 *   그렇다면 대체 값 타입 컬렉션은 언제 사용하나?
 *   - 정말 정말 정말 단순할때나 사용한다.(추적할 필요도 없고 수정할 필요도 없을 때만!)
 *   - 나머지는 전부 엔티티로 설계해야한다.
 *
 *   정리
 *   - 엔티티 타입 특징 : 식별자 있음, 스스로 생명 주기 관리, 공유 가능
 *   - 값 타입 특징 : 식별자 없음, 생명 주기를 주인 엔티티에 의존, 공유 하지 않는 것이 안전(복사 사용), 불변 객체로 만듬
 *   - 값 타입은 정말 값 타입이라고 판단될 때만 사용!
 *   - 엔티티와 값 타입을 혼동해서 엔티티를 값 타입으로 만들면 안된다!
 *   - 식별자가 필요하고 지속적으로 값을 추적 및 변경해야 한다면 그것은 값 타입이 아닌 엔티티다!
 */
public class ValueMain {

    public static void main(String[] args) {
        int a = 10;
        int b = 10;
        System.out.println("a == b : " + (a == b));

        Address address1 = new Address("city", "street", "100");
        Address address2 = new Address("city", "street", "100");
        System.out.println("address1 == address2 : " + (address1 == address2));
        System.out.println("address1 equals address2 : " + (address1.equals(address2)));
    }
}
